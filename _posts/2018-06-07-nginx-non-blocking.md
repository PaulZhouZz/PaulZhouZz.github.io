---
layout: post
title: "Nginx 非阻塞的概念"
description: ""
category: tech
tags: [nginx]
excrept: Nginx入门指南中关于非阻塞概念的一段截取
---
{% include JB/setup %}


###nginx
Nginx 采用的是异步非阻塞方式处理。那么什么是异步非阻塞呢。 
nginx请求具体到系统底层，就是读写事件，而当读写事件没有准备好时，必然不可操作，如果不用非阻塞的方式来调用，那就得阻塞调用，即事件没有准备好，那就只能等了，等事件准备好了，在继续往下执行。 阻塞调用会进入内核等待，cpu就会让出去给别人使用，对于单线程的worker来说，显然不合适，当网络事件越多时，大家都在等待呢，cpu空闲下来没人用，cpu利用率自然上不去，更别谈高并发了。 
所以，在Nginx里面，最忌讳阻塞的系统调用，不要阻塞，那就使用非阻塞。非阻塞就是，事件没有准备好，马上返回EAGAIN，告诉你事件还没有准备好。稍后再次尝试，。然后过一会，再来检查一下事件，知道事件准备好了为止，在这期间，你就可以先去做其他的事情，然后再来看看事件好了没，虽然不阻塞了，但是需要不时的检查一下事件的状态，你可以做更多的事情，但带来的开销也是不小的。
所以，才会有了异步非阻塞的事件处理机制，具体到系统调用就是像select/poll/epoll/kququ这样的系统调用。他们提供了一种机制，让你可以同时监控多个时间，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有时间准备好了，就返回。这种机制正好解决了我们上面的两个问题，那epoll为例，当事件没准备好时，放到epoll里面，事件准备好了，我们就去读写，当读写返回EAGAIN时，我们将它再次加入到epoll里面。这样，只要有事件准备好，我们就去处理它，只有当所有事件都没准备好时，才在epoll里面等着。这样，我们就可以并发处理大量的并发了，当然，这里的并发请求，是指未处理完的请求，线程只有一个，所以同时能处理的请求当然只有一个，只是在请求间进行不断地切换而已，切换也是因为异步事件未准备好，而主动让出的。这里的切换是没有任何代价的，可以理解为循环处理多个准备好的时事件，事实上就是这样的，与多线程相比，这种事件处理方式是有很大优势的。不需要创建线程，每个请求暂用的内存也很少，没有上下文切换，事件处理非常轻量级。并发数再多也不会导致无畏的资源浪费。